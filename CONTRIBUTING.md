# CONTRIBUTING.md

Добро пожаловать в проект LearningPlatform! Этот документ описывает правила контрибуции, стиль кода, оформление PR и общий порядок работы для всех участников команды.

Документ обязателен для соблюдения всеми разработчиками.

---

# 1. Общие принципы

* Каждый микросервис — отдельный изолированный Python-проект.
* Взаимное импортирование моделей между сервисами **запрещено**.
* Вся логика и код пишутся в едином стиле.
* Перед каждым коммитом код автоматически форматируется и проверяется.
* В PR не должно попадать "случайного мусора": временные файлы, недописанные функции, лишние импорты.

---

# 2. Стиль кода

## 2.1 Python

Во всех микросервисах используется единый стек форматирования и линтинга:

* **black** — форматирование кода;
* **ruff** — линтер для поиска ошибок и приведения импортов в порядок;
* **mypy** — опционально для статической проверки типов.

## 2.2 Общие правила

* Максимальная длина строки — **100 символов**.
* Строки — двойные кавычки (`"example"`).
* Отступы — 2 пробела.
* Импорты должны быть отсортированы (`ruff` это делает автоматически).
* Везде, где возможно, использовать modern-typing:

  * вместо `Optional[str]` → `str | None`;
  * вместо `List[int]` → `list[int]`.

## 2.3 .editorconfig

В корне проекта лежит `.editorconfig`, который автоматически задаёт:

* LF переводы строк;
* UTF-8 кодировку;
* 2-пробельные отступы для Python;
* 2-пробельные отступы для YAML/TOML.

Редактор должен поддерживать `.editorconfig` (VS Code, PyCharm — поддерживают).

---

# 3. Pre-commit

Перед разработкой необходимо установить pre-commit:

```bash
pip install pre-commit
pre-commit install
```

После установки, перед каждым коммитом будут запускаться:

* `ruff` — проверит ошибки и стиль импортов;
* `black` — отформатирует код.

Если pre-commit не проходит — коммит не создаётся. Исправьте ошибки и повторите.

Запуск pre-commit вручную:

```bash
pre-commit run --all-files
```

---

# 4. Линтинг и форматирование

## 4.1 Проверить качество кода

```bash
ruff check .
```

## 4.2 Авто-исправить всё, что возможно

```bash
ruff check . --fix
```

## 4.3 Форматировать код по black

```bash
black app
```

## 4.4 Полный цикл проверки

```bash
ruff check . --fix
black app
ruff check .
```

---

# 5. Оформление Commit сообщений

Используем упрощённый вариант Conventional Commits:

Примеры допустимых префиксов:

* `feat:` — новая функциональность;
* `fix:` — исправление ошибки;
* `refactor:` — рефакторинг без изменения поведения;
* `docs:` — изменения в документации;
* `test:` — добавление или изменение тестов;
* `chore:` — обновление зависимостей, вспомогательные задачи.

Примеры правильных коммитов:

```
feat: add login endpoint
fix: correct JWT expiration handling
refactor: move user repository to separate file
docs: update README usage instructions
```

Неправильные коммиты:

```
fix
правки
111
update
```

---

# 6. Оформление Pull Requests

Каждый PR должен содержать:

1. **Краткое описание** — что сделано.
2. **Зачем** — мотивация изменения.
3. **Ссылку на задачу** (например, KAN-26).
4. Чистую историю коммитов.
5. Все проверки CI должны быть зелёными.

## Требования к PR

* PR должен быть **небольшим**, не более ~300–400 строк diff, если возможно.
* PR не должен содержать неиспользуемого кода, временных решений, закомментированных кусков.
* Все замечания ревью должны быть исправлены или аргументированно отклонены.
* Самослияние без ревью — запрещено.

---

# 7. CI / CD

В CI должны выполняться:

* `ruff check`;
* `black --check`;
* тесты (когда появятся);
* миграции должны применяться корректно.

Если один из этапов падает — PR не может быть смёржен.

---

# 8. Работа с микросервисами

Каждый микросервис имеет свой `pyproject.toml` и свои dev-зависимости.

Перед работой с сервисом:

```bash
pip install -e .[dev]
```

Стиль, линтинг и форматирование запускаются в контексте конкретного сервиса.

---

# 9. Как быстро найти плохой код

```bash
ruff check .
ruff check . --fix
black app
ruff check .
```

Если после этих команд остались ошибки F*** (например, F401, F821, F841) —
это не стиль, а логическая ошибка, и её нужно исправлять вручную.

# 10. Утилита ResponseUtils

Для унифицированного ответа API во всех микросервисах используется утилита `ResponseUtils`. Она обеспечивает единый формат успешных и ошибочных ответов.
## Импортировать 
>from learning_platform_common.utils import ResponseUtils
## 10.1. Формат успешного ответа

```python
ResponseUtils.success(
    message: str | None = None,
    **kwargs
)
```

### Пример результата

```json
{
  "result": true,
  "message": "Успешно",
  "data": {...}
}
```

### Правила использования

* Используется **во всех успешных ручках**.
* Всегда возвращает ключ `result = true`.
* Дополнительные данные передаются через `**kwargs`.
* `message` — опциональный, но рекомендуется для POST/PUT/DELETE.

### Пример применения

```python
return ResponseUtils.success(message="Пользователь создан", user=user_dict)
```

---

## 10.2. Формат ошибки

```python
ResponseUtils.error(
    message: str = "Произошла ошибка"
)
```

### Пример результата

```json
{
  "result": false,
  "message": "Неверный пароль"
}
```

### Правила использования

* Применяется там, где нет исключения FastAPI, но требуется вернуть аккуратную ошибку.
* В случае бизнес-ошибок предпочтительно использовать:

  * `raise HTTPException(status_code=400, detail="...")`
  * **или** `ResponseUtils.error()` — если endpoint согласованно работает через JSON-ответы.

### Пример применения

```python
if not user:
    return ResponseUtils.error("Пользователь не найден")
```

---
